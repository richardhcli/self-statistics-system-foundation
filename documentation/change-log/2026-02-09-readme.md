# Changelog - 2026-02-09

## visual graph Read-Aside Hydration Pipeline
Refined CDAG initialization so the visual graph boots from IndexedDB but immediately forces a Firebase refresh for structure, nodes, and edges. This ensures the cached topology is overwritten by the backend source of truth on first load, resolving missing graph data after a fresh app launch.

The visual graph now follows a deterministic hydration pipeline to guarantee fast boot and accurate data:

1. **IndexedDB Hydration**: Zustand loads cached CDAG data immediately for instant rendering.
2. **Structure Fetch**: `users/{uid}/graphs/cdag_topology` is fetched and applied to overwrite stale cache metadata.
3. **Structure Subscription**: The structure document is subscribed to for live refreshes.
4. **Details Refresh**: Nodes and edges listed in `adjacencyList` are fetched from the `nodes` and `edges` subcollections to populate the full graph.

Implementation references:
- Graph read-aside service: [src/lib/firebase/graph-service.ts](../../src/lib/firebase/graph-service.ts)
- Store + cache logic: [src/stores/cdag-topology/store.ts](../../src/stores/cdag-topology/store.ts)
- Visual graph sync hook: [src/hooks/use-cdag-structure.ts](../../src/hooks/use-cdag-structure.ts)

## adjacency_list + node_summaries Collections
Refactored graph structure storage so adjacency and node summaries live in dedicated collections instead of dotted keys, keeping structure metadata in `cdag_topology` and ensuring updates propagate across nodes, edges, adjacency_list, and node_summaries.

Refined the CDAG fetch policy to perform a full node/edge sync once per app load and only repeat when cached data is stale, while lightweight collections continue to refresh structure summaries on each graph view focus.

Stale full fetches use a 30-minute TTL, keeping background reads minimal while preserving fresh graph data.

## Debug Blueprint: Graph Hydration Failure
The CDAG graph still failed to expand beyond IndexedDB despite Firebase data existing for nodes and edges. Recent fixes included forcing structure fetch + subscription, normalizing structure payloads, adding a full-fetch fallback, and logging the hydration steps.

Plan of action:
1. **Validate Firebase payloads**: Log a sample node/edge document and ensure required fields (`id`, `source`, `target`, `label`, `type`) match the expected types.
2. **Normalize read/write formats**: Apply shared serializers/normalizers to both writes (batch updates) and reads (doc snapshot data) so IDs and defaults are stable.
3. **Verify structure coverage**: Confirm `adjacencyList` and `nodeSummaries` contain the expected node IDs after the structure fetch.
4. **Check auth + rules**: Ensure the UID used by the graph fetch matches the user who owns the data and that Firestore rules permit reads.
5. **Telemetry checkpoints**: Add one-time logs for fetched counts (structure, nodes, edges) and compare them with Firestore console counts.
